\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{logictools}[2025/02/27 logictools]

\RequirePackage{xparse}
\RequirePackage{expl3}
\RequirePackage{stmaryrd}
\RequirePackage{filecontentsdef}
\RequirePackage{amsmath}
\RequirePackage{keyval}
\RequirePackage{nicefrac}
\RequirePackage{bussproofs}
\RequirePackage{adjustbox}
\RequirePackage{mathtools}
\DeclareOption{ptlp}{
    % Provides "y differs from x in at most v" sign
    \newcommand{\difmost}[1]{
    \overset{#1}{\sim}
    }
    
    % Provides logical comma symbol
    
    \newcommand{\lcma}{
    \adjustbox{trim={.45\width} 0pt 0pt 0pt ,clip}{$\circ$}
    }
}

\DeclareOption{proofs}{
    
% Super easy proof annotations in the style that Volker likes, with good(ish) kerning.
\newcommand{\andlabel}[1]{
\RightLabel{\scriptsize($\land$\hspace{1px}#1)}
}

\newcommand{\orlabel}[1]{
\RightLabel{\scriptsize($\lor$\hspace{1px}#1)}
}

\newcommand{\implieslabel}[1]{
\RightLabel{\scriptsize($\rightarrow$\hspace{0.5px}#1)}
}

\newcommand{\ifflabel}[1]{
\RightLabel{\scriptsize($\leftrightarrow$\hspace{0.5px}#1)}
}

\newcommand{\neglabel}[1]{
\RightLabel{\scriptsize($\neg$\hspace{0.5px}#1)}
}

\newcommand{\foralllabel}[1]{
\RightLabel{\scriptsize($\forall$\hspace{1px}#1)}
}

\newcommand{\existslabel}[1]{
\RightLabel{\scriptsize($\exists$\hspace{0.5px}#1)}
}

% Provides an easy way to notate an unspecified proof from a set of premisses
% Optionally, can include discharged assumptions

\makeatletter
\newcommand{\raisemath}[1]{\mathpalette{\raisem@th{#1}}}
\newcommand{\raisem@th}[3]{\raisebox{#1}{$#2#3$}}
\makeatother

\NewDocumentCommand{\prooffrom}{m m o}
{%
\IfNoValueTF{#3}
    {\alwaysNoLine
    \AxiomC{\fbox{#1}}
    \UnaryInfC{\raisebox{0.75ex}[3.25ex]{\smash{\vdots}}}
    \UnaryInfC{#2}
    \alwaysSingleLine}
    {\alwaysNoLine
    \AxiomC{$\boxed{\text{#1}}^{\mathrlap{\raisemath{-0.65ex}{\hspace{0.1em}\text{#3}}}}$}
    \UnaryInfC{\raisebox{0.75ex}[3.25ex]{\smash{\vdots}}}
    \UnaryInfC{#2}
    \alwaysSingleLine}%
}%
}
\DeclareOption*{\PackageWarning{logictools}{Unknown ‘\CurrentOption’}}
\ProcessOptions\relax

%---------------------------------------------------------------------

\ExplSyntaxOn
\exp_args:Nc \mathchardef { __formal_original_): }=\char_value_mathcode:n {`)}
\exp_args:Nc \mathchardef { __formal_original_(: }=\char_value_mathcode:n {`(}
\exp_args:Nc \mathchardef { __formal_original_|: }=\char_value_mathcode:n {`|}
\exp_args:Nc \mathchardef { __formal_original_;: }=\char_value_mathcode:n {`;}
% Thanks to egreg from TeX-exchange for teaching me how to use expl3!
\tl_new:N \l__formal_rbracket_tl
\tl_new:N \l__formal_lbracket_tl
\keys_define:nn {options/formal}
 {
  parstackkern        .muskip_set:N = \l__formal_parstackkern_muskip,
  parinsidepad        .muskip_set:N = \l__formal_parinsidepad_muskip,
  italiccorrection    .muskip_set:N = \l__formal_italiccorrection_muskip,
  parvoffset          .dim_set:N = \l__formal_parvoffset_dim,
  existskern          .muskip_set:N = \l__formal_existskern_muskip,
  forallkern          .muskip_set:N = \l__formal_forallkern_muskip,
  quantkern .meta:n = {
    existskern = #1 ,
    forallkern = #1 ,
  },
  lastquantkern       .muskip_set:N = \l__formal_lastquantkern_muskip,
  scriptspace         .muskip_set:N = \l__formal_scriptspace_muskip,

  parstackkern        .default:n = -0.9mu,
  parinsidepad        .default:n = 0.9mu,
  italiccorrection    .default:n = 1.62mu,
  parvoffset          .default:n = 0.2ex,
  quantkern           .default:n = 3.24mu,
  lastquantkern       .default:n = 4.32mu,
  partype             .default:n = double,
  scriptspace         .default:n = -0.45mu,
  
  partype .tl_set:N = \l__formal_partype_tl,
  partype .choice:,
  
  partype / double .code:n = 
  \tl_set:Nn \l__formal_partype_tl {double} % futureproofing, unnecessary
  \tl_set:Nn \l__formal_rbracket_tl {\rrparenthesis}
  \tl_set:Nn \l__formal_lbracket_tl {\llparenthesis},
  
  partype / single .code:n = 
  \tl_set:Nn \l__formal_partype_tl {single} % futureproofing, unnecessary
  \tl_set:Nn \l__formal_rbracket_tl {%\char_set_mathcode:nn {41} {41} $)$}
  \use:c{__formal_original_):}}
  \tl_set:Nn \l__formal_lbracket_tl {%\char_set_mathcode:nn {40} {40} $($},
  \use:c{__formal_original_(:}},
  partype / unknown .code:n =
    \msg_error:nneee { options/formal } { unknown_bracket_type }
        { partype } % Name of choice key
        { double , single } % Valid choices
        { \exp_not:n {#1} } % Invalid choice given
 }
% Initialise all the keys
\keys_set:nn {options/formal}
     {
      parstackkern,
      parinsidepad,
      italiccorrection,
      parvoffset,
      quantkern,
      lastquantkern,
      partype,
      scriptspace,
     }

\tl_new:N \l__formal_logic_tl
\seq_new:N \l__formal_logic_seq


\cs_new_protected:Nn \__formal_llpar_stack:
  {
    \raisebox{\l__formal_parvoffset_dim}{\l__formal_lbracket_tl \mkern \l__formal_parstackkern_muskip}
  }
\cs_new_protected:Nn \__formal_llpar:
  {
    \raisebox{\l__formal_parvoffset_dim}{\l__formal_lbracket_tl} \mskip \l__formal_parinsidepad_muskip
  }
\cs_new_protected:Nn \__formal_rrpar_stack:
  {
    \raisebox{\l__formal_parvoffset_dim}{\mkern \l__formal_parstackkern_muskip \l__formal_rbracket_tl}
  }
\cs_new_protected:Nn \__formal_rrpar:
  {
    \mskip{\l__formal_italiccorrection_muskip+\l__formal_parinsidepad_muskip} \raisebox{\l__formal_parvoffset_dim}{\l__formal_rbracket_tl}
  }

\NewDocumentEnvironment {formallogic} {O{} +b}
  {
    \setlength{\parindent}{0pt}
    \cs_set:Npn \par {$\newline$}
    \keys_set:nn {options/formal} % Load any settings given in the optional argument.
     {
      #1,
     }
    \setlength\scriptspace{\l__formal_scriptspace_muskip} 
    \tl_set:Nn \l__formal_logic_tl { #2 }

    %\regex_split:nVN  {([\( \ ]+ | [\) \ ]+ |\;.+\;)} {\l__formal_logic_tl} \l__formal_logic_seq
    %\seq_show:N \l__formal_logic_seq
    %\seq_set_map:NNn \l__formal_logic_seq \l__formal_logic_seq 
    %{
    %\str_if_eq:eeTF {\tl_head:n {##1}} {(} 
    %{\tl_map_inline:nn {##1} {\__formal_llpar_stack:}}
    %{##1}
    %}
    %\seq_set_map:NNn \l__formal_logic_seq \l__formal_logic_seq
    %{
    %    \str_case_e:enF {\tl_head:n {##1}}
    %  {
    %    {(} {\tl_map_inline:nn {##1} {\__formal_llpar_stack:}}
    %    %\__formal_llpar_stack:}
    %    {)} {\tl_map_inline:nn {##1} {\__formal_rrpar_stack:}}
    %    %\__formal_rrpar_stack:}
    %    {;} {\tl_range:nnn {##1} {2}{-2}}
    %  }
    %  {##1} % Default case: return the original string
    %}
    
    \char_set_active_eq:nN { `( } \__formal_llpar_stack:
    \char_set_mathcode:nn { `( } { "8000 }
    \char_set_active_eq:nN { `) } \__formal_rrpar_stack:
    \char_set_mathcode:nn { `) } { "8000 }
    \char_show_value_mathcode:n {`)}
    \regex_split:nVN  {([\( \ ]+ | [\) \ ]+ |\;.+\;)} {\l__formal_logic_tl} \l__formal_logic_seq
    %\tl_set:Nx \l__formal_logic_tl {  }
    \seq_remove_all:Nn \l__formal_logic_seq {}
    \seq_show:N \l__formal_logic_seq
    
    \tl_set:Nx \l__formal_logic_tl { \seq_use:Nn \l__formal_logic_seq {\mskip{\l__formal_parinsidepad_muskip - \l__formal_parstackkern_muskip}} }
    %\ensuremath{\seq_use:Nn \l__formal_logic_seq {\mskip{\l__formal_parinsidepad_muskip - \l__formal_parstackkern_muskip}}}
    
    % Search for stacked quantifiers and add appropriate kerning in between.
    \regex_replace_all:nnN
    {
    ([\c{exists} \c{forall}]\w+) \h (\c{forall})
    }
    {
    \1 \c{mskip}{\c{l__formal_forallkern_muskip}} \2
    }
    \l__formal_logic_tl

    % You have to do it twice unfortunately, the capture groups only get half of the quantifiers.
    \regex_replace_all:nnN
    {
    ([\c{exists} \c{forall}]\w+) \h (\c{forall})
    }
    {
    \1 \c{mskip}{\c{l__formal_forallkern_muskip}} \2
    }
    \l__formal_logic_tl
    
    % Same for exists quantifier...
    \regex_replace_all:nnN
    {
    ([\c{exists} \c{forall}]\w+) \h (\c{exists})
    }
    {
    \1 \c{mskip}{\c{l__formal_existskern_muskip}} \2
    }
    \l__formal_logic_tl

    \regex_replace_all:nnN
    {
    ([\c{exists} \c{forall}]\w+) \h (\c{exists})
    }
    {
    \1 \c{mskip}{\c{l__formal_existskern_muskip}} \2
    }
    \l__formal_logic_tl

    % Search for quantifiers at the end of a stack and add kerning.
    \regex_replace_all:nnN
    {
    ([\c{exists} \c{forall}]\w+) \s ([^\c{exists} \c{forall}])
    }
    {
    \1 \c{mskip}{\c{l__formal_lastquantkern_muskip}} \2
    }
    \l__formal_logic_tl

    % Search and replace ".=" with an equals sign with a dot over.
    \regex_replace_all:nnN {\.=} {\c{doteq}}
    \l__formal_logic_tl

    % Search for variable substitutions (anything of the form [xyz/abc] with no spaces) and replace with nice looking version.
    \regex_replace_all:nnN
        {
        \[(\S+)/(\S+)\]
        }
        {[\c{nicefrac}{\1}{\2}]}
        \l__formal_logic_tl
        
    
    \ensuremath{\tl_use:N \l__formal_logic_tl}\ignorespacesafterend
  }{}

\NewDocumentEnvironment{fastfmllgc}{O{} +b}
{
\setlength{\parindent}{0pt}
\cs_set:Npn \par {$\newline$}
\keys_set:nn {options/formal} % Load any settings given in the optional argument.
     {
      #1,
     }
\setlength\scriptspace{\l__formal_scriptspace_muskip} 
\tl_set:Nn \l__formal_logic_tl { #2 }

\regex_replace_case_all:nN
      {
        { \" (.*?) \" } { \1 }
        {\| (.*?)\| } { QS:\1:}
        {\(+|\)+} {\c{tl_if_head_eq_charcode:nNTF}{\0} ( 
            { \c{prg_replicate:nn}{\c{tl_count:e} {\0}-1} {\c{__formal_llpar_stack:}} \c{__formal_llpar:} }
            {\c{__formal_rrpar:} \c{prg_replicate:nn}{\c{tl_count:e} {\0}-1} {\c{__formal_rrpar_stack:}} }}
     
      } \l__formal_logic_tl

\ensuremath{\tl_use:N \l__formal_logic_tl}\ignorespacesafterend
}{}

%\RenewDocumentEnvironment {formallogic} {O{} +b} {}{}

\cs_new_protected:Nn \__formal_replace:n
  {
    \str_case:nnF {#1}
      {
        {(} {\__formal_llpar_stack:}
        {)} {\__formal_rrpar_stack:}
        {.=} {\doteq}
        {[\S+/\S+]} {[\nicefrac{\1}{\2}]}
        {[\c{exists} \c{forall}]\w+ \h [\c{exists} \c{forall}]}
          {\1 \hspace{\l__formal_forallkern_muskip} \2}
        {[\c{exists} \c{forall}]\w+ \s [^\c{exists} \c{forall}]}
          {\1 \hspace{\l__formal_lastquantkern_muskip} \2}
      }
      {#1} % Default case: return the original string
  }

\cs_new_protected:Nn \__formal_parreplace:n
{
\tl_if_head_eq_charcode:nNTF{#1} ( 
    { \c{prg_replicate:nn}{\c{tl_count:e} {#1}} {\c{__formal_llpar_stack:}} }
    { \c{prg_replicate:nn}{\c{tl_count:e} {#1}} {\c{__formal_rrpar_stack:}} }
}


\seq_new:N \l__formal_quantstack_seq
\cs_new_protected:Nn \__formal_quantstackparse:n
{
\seq_set_split:Nnn \l__formal_quantstack_seq {:} {#1}
}

% Use this command to declare settings that will stay for the rest of the document!
\DeclareDocumentCommand \logictoolsoptions { m }
{
\keys_set:nn {options/formal} 
    {
    #1 
    }
}
\ExplSyntaxOff

% Command that puts things inside the above environment, can be used inline.
\newcommand{\fmllgc}[1]{
\begin{formallogic}#1
\end{formallogic}
}

% Consistent naming scheme for logical operators
\newcommand{\limplies}{\rightarrow}
\newcommand{\liff}{\leftrightarrow}
%--------------------------------------------------

\ExplSyntaxOn
% Some commands for turning latin characters into greek ones
\NewDocumentCommand{\ucgreek}{m}
 {
  \str_case_e:nnF { #1 }
   {
    {A}{\mathrm{A}}
    {B}{\mathrm{B}}
    {C}{\Sigma}
    {D}{\Delta}
    {E}{\mathrm{E}}
    {F}{\Phi}
    {G}{\Gamma}
    {H}{\mathrm{H}}
    {I}{\mathrm{I}}
    {J}{\Theta}
    {K}{\mathrm{K}}
    {L}{\Lambda}
    {M}{\mathrm{M}}
    {N}{\mathrm{N}}
    {O}{\mathrm{O}}
    {P}{\Pi}
    {Q}{\mathrm{X}}
    {R}{\mathrm{P}}
    {S}{\Sigma}
    {T}{\mathrm{T}}
    {U}{\Upsilon}
    {V}{\mathrm{V}}
    {W}{\Omega}
    {X}{\Xi}
    {Y}{\Psi}
    {Z}{\mathrm{Z}}
   }
   {#1}
 }
\NewDocumentCommand{\lcgreek}{m}
 {
  \str_case_e:nnF { #1 }
   {
    {a}{\alpha}
    {b}{\beta}
    {c}{\varsigma}
    {d}{\delta}
    {e}{\varepsilon}
    {f}{\varphi}
    {g}{\gamma}
    {h}{\eta}
    {i}{\iota}
    {j}{\vartheta}
    {k}{\kappa}
    {l}{\lambda}
    {m}{\mu}
    {n}{\nu}
    {o}{o}
    {p}{\pi}
    {q}{\chi}
    {r}{\rho}
    {s}{\sigma}
    {t}{\tau}
    {u}{\upsilon}
    {v}{\nu}
    {w}{\omega}
    {x}{\xi}
    {y}{\psi}
    {z}{\zeta}
   }
   {#1}
 }

% A way to call these commands on "\text{stuff}" instead of just "stuff"
\NewDocumentCommand{\textgreek}{m}
{
    \tl_set:Nn \l__arg_tl { #1 }
    \regex_replace_all:nnN {\c{text}\{([a-z])\}}{\c{lcgreek}{\1}}
    \l__arg_tl
    \regex_replace_all:nnN {\c{text}\{([A-Z])\}}{\c{ucgreek}{\1}}
    \l__arg_tl

    \tl_use:N \l__arg_tl
}

\ExplSyntaxOff
% Provides semantic value function
% Gives automatic mathcal letters for the structure
% Optionally gives a variable assignment, where if a single Latin letter is input then it will return the associated Greek symbol.
\NewDocumentCommand{\semval}{m m o}
{%
\IfNoValueTF{#3}
    {\text{$|#1|_{\mathcal{#2}}$}}
    {\text{$|#1|_{\mathcal{#2}}^{\textgreek{\text{#3}}}$}}%
}%

%-----------------------------------------------------------------------------

% Shorter equals sign
\makeatletter
\newcommand{\shorteq}{%
  \settowidth{\@tempdima}{$x$}% Width of x in mathfont
  \resizebox{\@tempdima}{\height}{=}%
}
\makeatother

\ExplSyntaxOn
% Provides the symbols for l-one, l-two, l-equals and nice looking superscript
\NewDocumentCommand{\lsym}{m o}%
{
\IfNoValueTF{#2}
    {% No superscript:
        \str_case:nnF {#1}
        {
            {1}{\text{$\mathcal{L}\sb{1}$}}
            {2}{\text{$\mathcal{L}\sb{2}$}}
            {=}{\text{$\mathcal{L}\sb{\text{\hspace{0.01em}\shorteq}}$}}
        }
        {\text{$\mathcal{L}\sb{\text{#1}}$}}
    }
    {% Superscript:
        \str_case:nnF {#1}
        {
            {1}{\text{$\mathcal{L}\sb{1}^{\text{#2}}$}}
            {2}{\text{$\mathcal{L}\sb{2}^{\text{#2}}$}}
            {=}{\text{$\mathcal{L}\sb{\text{\hspace{0.01em}\shorteq}}^{\text{#2}}$}}
        }
        {\text{$\mathcal{L}\sb{\text{#1}}^{\text{#2}}$}}
    }
}

\ExplSyntaxOff




\makeatletter
\edef\originalbmathcode{%
    \noexpand\mathchardef\noexpand\@tempa\the\mathcode`\(\relax}
\def\resetMathstrut@{%
  \setbox\z@\hbox{%
    \originalbmathcode
    \def\@tempb##1"##2##3{\the\textfont"##3\char"}%
    \expandafter\@tempb\meaning\@tempa \relax
  }%
  \ht\Mathstrutbox@\ht\z@ \dp\Mathstrutbox@\dp\z@
}
\makeatother